#!/usr/bin/perl

package main;

use 5.10.0;
use warnings;
use strict;

use Getopt::Long;
Getopt::Long::Configure('pass_through', 'no_auto_abbrev');

use Locale::gettext;

use Cupt::Core;
use Cupt::Config;
use Cupt::Cache;
use Cupt::Cache::Relation qw(stringify_relations);
use Cupt::System::Resolver;
use Cupt::System::Worker;

my $config;
my $cache;

# build config at start
eval {
	$config = new Cupt::Config;
};
if (mycatch()) {
	myerr("error while loading config");
	exit 1;
}

process_options();

my $command = shift @ARGV;
while ($command =~ m/^-/) { # this is some option which may be processed later
	my $new_command = shift @ARGV;
	unshift @ARGV, $command;
	$command = $new_command;
}

myerr("no command specified") and exit 2 if (!defined($command));

my %command_handlers = (
	'config-dump' => \&config_dump,
	'show' => \&show_package_versions,
	'search' => \&search,
	'depends' => \&show_package_relations,
	'policy' => \&policy,
	'pkgnames' => \&pkgnames,
	'install' => \&install,
	'remove' => \&remove,
	'purge' => \&purge,
	'safe-upgrade' => \&safe_upgrade,
	'full-upgrade' => \&full_upgrade,
);

if (defined($command_handlers{$command})) {
	eval {
		$command_handlers{$command}->();
	};
	if (mycatch()) {
		myerr("error performing command '%s'", $command);
		exit 3;
	}
} else {
	myerr("unrecognized command '%s'", $command) and exit 2;
}

sub build_cache {
	eval {
		# propagate any parameters passed to Cupt::Cache::&new
		$cache = new Cupt::Cache($config, @_);
	};
	if (mycatch()) {
		myerr("error while creating package cache");
		exit 1;
	}
}

sub check_package_name ($) {
	if (! ($_[0] =~ m/^$package_name_regex$/)) {
		mydie("bad package name '%s'", $_[0]);
	}
}

sub check_version_string ($) {
	if (! ($_[0] =~ m/^$version_string_regex$/)) {
		mydie("bad version string '%s'", $_[0]);
	}
}

sub check_no_extra_args () {
	if (scalar @ARGV > 0) {
		mywarn("extra arguments '%s' are not processed", "@ARGV");
	}
}

sub check_no_more_options () {
	foreach (@ARGV) {
		m/^-/ and mydie("unknown option '%s'", $_);
	}
}
sub get_binary_package ($) {
	my ($package_name) = @_;
	my $package = $cache->get_binary_package($package_name);
	if (defined $package) {
		return $package;
	} else {
		mydie("cannot find binary package '%s'", $package_name);
	}
}

sub human_readable_size_string ($) {
	my ($bytes) = @_;

	return "$bytes B" if ($bytes < 10*1024);
	return sprintf("%.1f KiB", ($bytes / 1024)) if ($bytes < 100*1024);
	return sprintf("%.0f KiB", ($bytes / 1024)) if ($bytes < 10*1024*1024);
	return sprintf("%.1f MiB", ($bytes / (1024*1024))) if ($bytes < 100*1024*1024);
	return sprintf("%.0f MiB", ($bytes / (1024*1024))) if ($bytes < 10*1024*1024*1024);
	return sprintf("%.1f GiB", ($bytes / (1024*1024*1024)));
}

sub select_binary_package_version ($) {
	my ($package_expression) = @_;

	if ($package_expression =~ m/^(.*?)=(.*)/) {
		# selecting by strict version string
		my $package_name = $1;
		check_package_name($package_name);
		my $version_string = $2;
		check_version_string($version_string);
		# example: "nlkt=0.3.2.1-1"
		foreach my $version (@{get_binary_package($package_name)->versions()}) {
			if ($version->{version} eq $version_string) {
				# found such a version
				return $version;
			}
		}
		# not found
		mydie("cannot find version '%s' for package '%s'", $version_string, $package_name);
	} elsif ($package_expression =~ m/^(.*?)\/(.*)/) {
		# selecting by release distibution
		my $package_name = $1;
		check_package_name($package_name);
		my $distribution_expression = $2;
		if (! ($distribution_expression =~ m/^[a-z]+$/)) {
			mydie("bad distribution '%s' requested, use archive or codename", $distribution_expression);
		}
		# example: "nlkt/sid" or "nlkt/unstable"
		foreach my $version (@{get_binary_package($package_name)->versions()}) {
			# 'avail as' for non-local versions
			my @avail_as = @{$version->{avail_as}};
			# first avail entry is for local version
			shift @avail_as if $version->is_local();

			foreach (@avail_as) {
				if (defined($_->{release}) and
					$_->{release}->{archive} eq $distribution_expression ||
					$_->{release}->{codename} eq $distribution_expression)
				{
					# found such a version
					return $version;
				}
			}
		}
		# not found
		mydie("cannot find distribution '%s' for package '%s'", $distribution_expression, $package_name);
	} else {
		my $result_version = $cache->get_policy_version(get_binary_package($package_expression));
		return $result_version;
	}
}

sub config_dump () {
	check_no_more_options();
	check_no_extra_args();

	my $print_key_value = sub {
		my $key = shift;
		my $value = shift;
		print $key, ' ', "\"", $value, "\"\n";
	};

	my @regular_keys = sort keys %{$config->{regular_vars}};
	foreach my $key (@regular_keys) {
		$print_key_value->($key, $config->{regular_vars}->{$key});
	}

	my @list_keys = sort keys %{$config->{list_vars}};
	foreach my $key (@list_keys) {
		my @values = @{$config->{list_vars}->{$key}};
		foreach (@values) {
			$print_key_value->("${key}::", $_);
		}
	}
}

sub show_package_versions () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	my $o_with_release_info = 0;
	GetOptions(
		'--with-release-info' => \$o_with_release_info
	);

	check_no_more_options();

	my @package_expressions = @ARGV;
	foreach my $package_expression (@package_expressions) {
		my $package_name;
		my $ref_versions;
		if ($config->var('apt::cache::allversions')) {
			$package_name = $package_expression;
			$ref_versions = get_binary_package($package_name)->versions();
		} else {
			my $version = select_binary_package_version($package_expression);
			$package_name = $version->{package_name};
			$ref_versions = [ $version ];
		}

		my $p = sub { print shift, ': ', shift, "\n" };
		foreach my $version (@$ref_versions) {
			$p->(__('Package'), $package_name);
			$p->(__('Version'), $version->{version});
			my $installed_status = $cache->{system_state}->get_status_for_version($version);
			$p->(__('Status'), defined($installed_status) ? $installed_status->{'status'} : "not installed");
			$p->(__('Source'), $version->{source_name});
			$p->(__('Essential'), $version->{essential}) if defined($version->{essential});
			$p->(__('Priority'), $version->{priority});
			$p->(__('Section'), $version->{section});
			$p->(__('Size'), human_readable_size_string($version->{size})) if defined($version->{size});
			$p->(__('Uncompressed size'), human_readable_size_string($version->{installed_size}*1024));
			$p->(__('Maintainer'), $version->{maintainer});
			$p->(__('Architecture'), $version->{architecture});
			if ($o_with_release_info) {
				foreach (@{$version->{avail_as}}) {
					next if !defined($_->{release}->{description}); # no release description available
					$p->(__('Release'), $_->{release}->{description});
				}
			}
			$p->(__('PreDepends'), stringify_relations($version->{pre_depends})) if defined($version->{pre_depends});
			$p->(__('Depends'), stringify_relations($version->{depends})) if defined($version->{depends});
			$p->(__('Recommends'), stringify_relations($version->{recommends})) if defined($version->{recommends});
			$p->(__('Suggests'), stringify_relations($version->{suggests})) if defined($version->{suggests});
			$p->(__('Conflicts'), stringify_relations($version->{conflicts})) if defined($version->{conflicts});
			$p->(__('Replaces'), stringify_relations($version->{replaces})) if defined($version->{replaces});
			$p->(__('Provides'), join(", ", @{$version->{provides}})) if defined($version->{provides});
			$p->(__('Enhances'), stringify_relations($version->{enhances})) if defined($version->{enhances});
			foreach ($version->uris()) {
				$p->(__('URI'), ($_ eq "" ? gettext("<locally installed>") : $_));
			}
			$p->(__('MD5'), $version->{md5sum}) if defined($version->{md5sum});
			$p->(__('SHA1'), $version->{sha1sum}) if defined($version->{sha1sum});
			$p->(__('SHA256'), $version->{sha256sum}) if defined($version->{sha1sum});
			$p->(__('Description'), $version->{short_description});
			# TODO: translated descriptions...
			print $version->{long_description} if defined($version->{long_description});
			$p->(__('Homepage'), $version->{homepage}) if defined($version->{homepage});
			$p->(__('Task'), $version->{task}) if defined($version->{task});
			$p->(__('Tags'), $version->{tags}) if defined($version->{tags});
			print "\n";
		}
	}
}

sub search () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 0);

	# turn off relations parsing, we don't need them
	$Cupt::Cache::BinaryVersion::o_no_parse_relations = 1;

	my $o_names_only = 0;
	my $o_case_sensitive = 0;
	GetOptions(
		'names-only|n' => sub { $config->set_regular_var('apt::cache::namesonly', 1) },
		'case-sensitive' => \$o_case_sensitive,
	);

	my $pattern = shift @ARGV;
	check_no_more_options();
	check_no_extra_args();

	my $regex = $o_case_sensitive ? qr/$pattern/ : qr/$pattern/i;

	if ($config->var('apt::cache::namesonly')) {
		# search only in package names
		foreach (keys %{$cache->{binary_packages}}) {
			if (m/$regex/) {
				say;
			}
		}
	} else {
		PACKAGE:
		while (my ($package_name, $package) = each %{$cache->{binary_packages}}) {
			if ($package_name =~ m/$regex/) {
				say $package_name;
				next;
			}
			foreach (@{$package->versions()}) {
				if ($_->{short_description} =~ m/$regex/ or
					defined($_->{long_description}) && $_->{long_description} =~ m/$regex/)
				{
					say $package_name . " - " . $_->{short_description};
					next PACKAGE;
				}
			}
		}
	}
}

sub show_package_relations () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	# turn off info parsing, we don't need it, only relations :)
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;

	my $o_with_suggests = 0;
	GetOptions(
		'with-suggests' => \$o_with_suggests,
	);

	check_no_more_options();

	my @versions = map { select_binary_package_version($_) } @ARGV;

	# don't output the same version more than one time
	my %processed_entries;

	while (scalar @versions) {
		my $version = shift @versions;

		my $package_name = $version->{package_name};
		my $version_string = $version->{version};

		next if exists $processed_entries{$package_name,$version_string};
		$processed_entries{$package_name,$version_string} = 1;

		say "$package_name $version_string:";
		my @relation_groups = (
			[ $version->{pre_depends}, 'Pre-Depends' ],
			[ $version->{depends}, 'Depends' ],
		);
		if (!$config->var('apt::cache::important')) {
			push @relation_groups, 
					[ $version->{recommends}, 'Recommends' ];

			if ($o_with_suggests) {
				push @relation_groups,
						[ $version->{suggests}, 'Suggests' ];
			}
		}

		foreach my $item (@relation_groups) {
			next unless defined($item);

			my $relations = $item->[0];
			my $caption = $item->[1];
			my @split = split /, /,  stringify_relations($relations);
			my $starter = "  " . gettext($caption) . ": ";
			map { say $starter, $_; } @split;

			if ($config->var('apt::cache::recursedepends')) {
				# insert recursive depends into queue
				foreach (@$relations) {
					my $ref_satisfying_versions = $cache->get_satisfying_versions($_);
					# if some versions exist
					if (scalar @$ref_satisfying_versions) {
						# choose only one version
						push @versions, $ref_satisfying_versions->[0];
					}
				}
			}
		}
	}
}

sub policy () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	# turn off info and relations parsing, we don't need it
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;
	$Cupt::Cache::BinaryVersion::o_no_parse_relations = 1;

	check_no_more_options();

	my @packages = @ARGV;
	for my $package_name (@packages) {
		my $package = get_binary_package($package_name);
		my $policy_version = $cache->get_policy_version($package);

		my $installed_version_string = $cache->{system_state}->get_installed_version_string($package_name);
		say "$package_name:";
		say "  " . gettext('Installed') . ": " .
				(defined($installed_version_string) ?
				$installed_version_string : ('(' . gettext('none') . ')'));

		say "  " . gettext('Candidate') . ": " . $policy_version->{version};
		say "  " . gettext('Version table') . ":";

		my $ref_versions = $cache->get_sorted_pinned_versions($package);

		foreach my $entry (@$ref_versions) {
			my $version = $entry->{'version'};
			my $pin = $entry->{'pin'};

			if (defined($installed_version_string) && 
				$version->{version} eq $installed_version_string)
			{
				print " *** ";
			} else {
				print "     ";
			}

			say $version->{version} . ' ' . $pin;
			# throw out local version if present
			my @avail_as = @{$version->{avail_as}};
			shift @avail_as if $version->is_local();

			foreach (@avail_as) {
				print (' ' x 8);
				print ${$_->{ref_base_uri}} . ' ';
				say $_->{release}->{archive} . '/'. $_->{release}->{component} . ' ';
			}
			if ($version->is_local()) {
				say ' ' x 8, $config->var('dir::state::status');
			}
		}
	}
}

sub pkgnames () {
	build_cache(-source => 0, -binary => 1, -installed => 1);

	check_no_more_options();

	my $prefix = "";
	if (scalar @ARGV) {
		$prefix = quotemeta(shift @ARGV);
	}

	check_no_extra_args();

	while ((my $package_name) = each %{$cache->{binary_packages}}) {
		# check package name for pattern and output it
		$package_name =~ m/^$prefix/o and say $package_name;
	}
}

sub manage_packages ($) {
	# action can be 'install', 'remove', 'purge', 'safe-upgrade', 'full-upgrade'
	my ($action) = @_;

	local $| = 1;
	print __('Building the package cache... ');
	build_cache(-source => 0, -binary => 1, -installed => 1);
	say __('[done]');

	# turn off info parsing, we don't need it
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;

	check_no_more_options();

	print __('Initializing package resolver... ');
	my $resolver = new Cupt::System::Resolver($config, $cache);
	$resolver->import_installed_versions($cache->{system_state}->export_installed_versions());
	say __('[done]');

	print __('Scheduling requested actions... ');
	if ($action eq 'safe-upgrade' || $action eq 'full-upgrade') {
		my $o_no_remove = ($action eq 'safe-upgrade');
		$resolver->set_params('no-remove' => $o_no_remove);
		$resolver->upgrade();

		# despite the main action is {safe,full}-upgrade, allow package
		# modifiers in the command line just as with the install command
		$action = 'install';
	}

	my $o_purge = 0;
	if ($action eq 'purge') {
		$action = 'remove';
		$config->set_regular_var('cupt::worker::purge', 1)
	}

	my @package_expressions = @ARGV;
	foreach my $package_expression (@package_expressions) {
		if ($action eq 'install') {
			my $version = select_binary_package_version($package_expression);
			$resolver->install_version($version);
		} else { # 'remove'
			check_package_name($package_expression);
			defined($cache->get_binary_package($package_expression)) or
					mydie("unable to find binary package '%s'", $package_expression);

			$resolver->remove_package($package_expression);
		}
	}

	say __('[done]');

	print __('Resolving possible unmet dependencies... ');
	# TODO: query user
	$resolver->resolve( sub { return 1 } );
	say __('[done]');
	say "";

	# TODO: make $cache->get_system_state
	my $worker = new Cupt::System::Worker($config, $cache->{system_state});
	# TODO: make $resolver->export_packages
	$worker->set_desired_state($resolver->{packages});

	my $ref_actions_preview = $worker->get_actions_preview();
	my %action_names = (
		'install' => __('INSTALLED'),
		'remove' => __('REMOVED'),
		'upgrade' => __('UPGRADED'),
		'purge' => __('PURGED'),
		'downgrade' => __('DOWNGRADED'),
		'configure' => __('CONFIGURED'),
		'deconfigure' => __('DECONFIGURED'),
	);
	foreach my $action (qw(install upgrade remove purge downgrade configure deconfigure)) {
		my $ref_packages = $ref_actions_preview->{$action};
		scalar @$ref_packages or next; # don't print empty lists
		my $action_name = $action_names{$action};
		say sprintf __("The following packages will be %s:"), $action_name;
		say "";
		my @packages_list = sort @$ref_packages;
		say "@packages_list";
		say "";
	}
}

sub install () {
	manage_packages('install');
}

sub remove () {
	my $o_purge = 0;
	GetOptions(
		'purge' => \$o_purge,
	);
	manage_packages($o_purge ? 'purge' : 'remove');
}

sub purge () {
	manage_packages('purge');
}

sub full_upgrade () {
	manage_packages('full-upgrade');
}

sub safe_upgrade () {
	manage_packages('safe-upgrade');
}

sub process_options {
	# strip options out (for now)
	my @direct_options;
	eval {
		GetOptions(
			'o=s@' => \@direct_options,
			'important|i' => sub { $config->set_regular_var('apt::cache::important', 1) },
			'all-versions|a' => sub { $config->set_regular_var('apt::cache::allversions', 1) },
			'no-all-versions' => sub { $config->set_regular_var('apt::cache::allversions', 0) },
			'target-release|default-release|t=s' => sub { $config->set_regular_var('apt::default-release', $_[1]) },
			'recurse' => sub { $config->set_regular_var('apt::cache::recursedepends', 1) },
		);
		foreach (@direct_options) {
			if (m/(.*?)=(.*)/) {
				my ($key, $value) = ($1, $2);
				if ($key =~ m/^(.*?)::$/) {
					# this is list option
					$config->set_list_var($1, $value);
				} else {
					# regular option
					$config->set_regular_var($key, $value);
				}
			}
		}
	};
	if (mycatch()) {
		myerr("error while processing command-line options");
		exit 2;
	}
}

__END__

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2008 Eugene V. Lyubimkin

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

