#!/usr/bin/perl
#BEGIN { $SIG{__DIE__} = sub { require Carp; Carp::confess(@_) } }

package Cupt::Core;

use 5.10.0;
use warnings;
use strict;

require Exporter;
our @ISA = ("Exporter");
our @EXPORT = qw(
	&myprint &mywarn &myerr &myredie &mydie &myinternaldie &mycatch
	$package_name_regex $version_string_regex);

use Locale::gettext;

#sub __ {
#	return gettext(shift);
#}

textdomain("cupt");

sub myprint {
	print sprintf(gettext(shift), @_);
}

sub mywarn {
	print "W: ";
	myprint @_;
	print "\n";
}

sub myerr {
	print "E: ";
	myprint @_;
	print "\n";
}

sub myredie() {
	die 'Cupt::Error';
}

sub mydie {
	myerr @_;
	myredie();
}

sub myinternaldie {
	print "E: ", gettext("internal error: ");
	myprint @_;
	print "\n";
	exit 255;
}

sub mycatch() {
	# This subroutine is inspired from David Golden's Exception::Class::TryCatch::&catch
    my $err = $@;
    if ($err =~ m/^Cupt::Error/) {
        return 1;
	} elsif ($err ne "") {
		# some other error received, propagate it
		die $err;
    } else {
        return 0;
    }
}

our $package_name_regex = qr/[a-z_0-9.+-]+/;
our $version_string_regex = qr/[a-zA-Z+0-9~:.-]+/;

1;

package Cupt::ISCConfigParser;
# This package is modified version of Matt Dainly's BIND::Config::Parser

import Cupt::Core;
use Parse::RecDescent;

my $grammar = q{

	<autotree>

	program:
		  <skip: qr{\s*
		            (?:(?://|\#)[^\n]*\n\s*|/\*(?:[^*]+|\*(?!/))*\*/\s*)*
		           }x> statement(s?) eofile { $item[2] }

	statement:
		  simple | nested | list

	simple:
		  name value ';'

	nested:
		  name '{' statement(s?) '}' ';'

	list:
		  name '{' (value ';')(s?) '}' ';'

	name:
		  /([\w\/-]+::)*([\w\/-]+)/

	value:
		  /".*"/

	eofile:
		  /^\Z/
};

sub new {
	my $class = shift;

	my $self = {
		'_regular_handler' => undef,
		'_list_handler' => undef,
	};

	$self->{'_parser'} = new Parse::RecDescent($grammar)
		or myinternaldie("bad grammar");

	bless $self, $class;
	return $self;
}

sub parse_file {
	my $self = shift;
	my $conffile = shift;

	open(FILE, $conffile) or mydie("unable to open file %s: %s", $conffile, $!);
	my $text = join("", <FILE>);
	close FILE;

	defined( my $tree = $self->{'_parser'}->program($text) )
		or mydie("bad config in file %s", $conffile);

	$self->_recurse($tree, "");
}

sub set_regular_handler {;
	my $self = shift;
	$self->{'_regular_handler'} = shift;
}

sub set_list_handler
{
	my $self = shift;
	$self->{'_list_handler'} = shift;
}

sub _recurse {
	my $self = shift;
	my $tree = shift;
	my $name_prefix = shift;

	foreach my $node (@{$tree}) {
		if (exists $node->{'simple'}) {
			my $item = $node->{'simple'};
			$self->{'_regular_handler'}->( $name_prefix . $item->{'name'}->{'__VALUE__'}, $item->{'value'}->{'__VALUE__'} );
		} elsif (exists $node->{'list'}) {
			my $item = $node->{'list'};
			my $name = $item->{'name'}->{'__VALUE__'};
			while ((my $key, my $value) = each %$item) {
				if (ref($value) eq 'ARRAY') {
					# list items here
					foreach my $listitem (@$value) {
						$self->{'_list_handler'}->( $name_prefix . $name, $listitem->{'value'}->{'__VALUE__'} );
					}
					last; # should be only one array of list items
				}
			}
		} else {
			if (exists $node->{'nested'}) {
				my $item = $node->{'nested'};
				$name_prefix .= $item->{'name'}->{'__VALUE__'} . '::';
				$self->_recurse($item->{'statement(s?)'}, $name_prefix);
			}
		}
	}
}

1;

package Cupt::Config;

import Cupt::ISCConfigParser;
import Cupt::Core;

sub new {
	my $class = shift;
	# APT::Build-Essential "";
	# APT::Build-Essential:: "build-essential";
	# APT::Acquire "";
	# APT::Acquire::Translation "environment";
	# Dir::State::cdroms "cdroms.list";
	# Dir::State::userstatus "status.user";
	# Dir::Etc::vendorlist "vendors.list";
	# Dir::Etc::vendorparts "vendors.list.d";
	# Dir::Bin::methods "/usr/lib/apt/methods";
	# Dir::Log "var/log/apt";
	# Dir::Log::Terminal "term.log";
	#
	my $self = {
		regular_vars => {
			'acquire::http::dl-limit' => 0,
			'apt::acquire::max-default-age::debian-security' => 7,
			'apt::authentication::trustcdrom' => 0,
			'apt::default-release' => undef,
			'apt::install-recommends' => 1,
			'apt::install-suggests' => 0,
			'dir' => '/',
			'dir::bin::dpkg' => '/usr/bin/dpkg',
			'dir::cache' => 'var/cache/apt',
			'dir::cache::archives' => 'archives',
			'dir::etc' => 'etc/apt',
			'dir::etc::sourcelist' => 'sources.list',
			'dir::etc::sourceparts' => 'sources.list.d',
			'dir::etc::parts' => 'apt.conf.d',
			'dir::etc::main' => 'apt.conf',
			'dir::etc::preferences' => 'preferences',
			'dir::state' => 'var/lib/apt',
			'dir::state::lists' => 'lists',
			'dir::state::status' => '/var/lib/dpkg/status',
			'dpkg::tools::options::/usr/bin/apt-listchanges::version' => 2,
		},

		list_vars => {
			'apt::neverautoremove' => [],
			'apt::update::pre-invoke' => [],
			'apt::update::post-invoke' => [],
			'dpkg::pre-install-pkgs' => [],
		},

	};
	$self->{regular_vars}->{'apt::architecture'} = __get_architecture();
	bless $self, $class;
	$self->_read_configs();
	return $self;
}

sub var {
	my $self = shift;
	my $var_name = shift;
	if (exists ($self->{regular_vars}->{$var_name})) {
		return $self->{regular_vars}->{$var_name};
	} elsif (defined ($self->{list_vars}->{$var_name})) {
		return $self->{list_vars}->{$var_name};
	} else {
		mydie("attempt to get wrong option %s", $var_name);
	}
}

sub set_regular_var {
	my $self = shift;
	my $var_name = lc(shift);
	if (defined ($self->{regular_vars}->{$var_name})) {
		my $new_value = shift;
		$self->{regular_vars}->{$var_name} = $new_value;
	} else {
		mydie("attempt to set wrong option %s", $var_name);
	}
}

sub set_list_var {
	my $self = shift;
	my $var_name = lc(shift);
	if (defined ($self->{list_vars}->{$var_name})) {
		my $new_value = shift;
		push @{$self->{list_vars}->{$var_name}}, $new_value;
	} else {
		mydie("attempt to set wrong option %s", $var_name);
	}
}

sub _read_configs {
	my $self = shift;
	my $parser = new Cupt::ISCConfigParser;

	my $regular_option_sub = sub {
		my $option_name = shift;
		my $value = shift;
		$value =~ s/"(.*)"/$1/;
		$self->set_regular_var($option_name, $value);
	};

	my $list_option_sub = sub {
		my $option_name = shift;
		map { s/"(.*)"/$1/; $self->set_list_var($option_name, $_); } @_;
	};

	$parser->set_regular_handler($regular_option_sub);
	$parser->set_list_handler($list_option_sub);

	my $root_prefix = $self->var('dir');
	my $etc_dir = $self->var('dir::etc');

	my $parts_dir = $self->var('dir::etc::parts');
	my @config_files = glob("$root_prefix$etc_dir/$parts_dir/*");

	my $main_file = $self->var('dir::etc::main');
	push @config_files, "$root_prefix$etc_dir/$main_file";

	foreach (@config_files) {
		$parser->parse_file($_);
	}
}

sub __get_architecture {
	my $answer = qx/dpkg --print-architecture/;
	chomp($answer);
	return $answer;
}

package Cupt::Cache::Relation;

use Exporter qw(import);

import Cupt::Core;

our @EXPORT_OK = qw(&__parse_relation_line &stringify_relations);

sub new {
	my ($class, $unparsed) = @_;
	my $self = {
		package_name => undef,
		relation => undef,
		version => undef,
	};
	bless $self => $class;

	if ($unparsed =~ m/^($package_name_regex)/g) {
		# package name is here
		$self->{package_name} = $1;
	} else {
		# no package name, badly
		mydie("failed to parse package name in relation '%s'", $unparsed);
	}

	if ($unparsed =~ m/
			\G # start at end of previous regex
			\s* # possible spaces
			\( # open relation brace
				(
					>=|=|<=|<<|>>|<|> # relation
				)
				\s* # possible spaces
				(
					 $version_string_regex# version
				)
			\) # close relation brace
			$
		/xgc
	)
	{
		# versioned info is here, assigning
		($self->{relation}, $self->{version}) = ($1, $2);
	} else {
		# no valid versioned info, maybe empty?
		($unparsed =~ m/\G\s*$/g) # empty versioned info, this is also acceptable
			or mydie("failed to parse versioned info in relation '%s'", $unparsed); # what else can we do?..
	}

	return $self;
}

sub stringify {
	my $self = shift;
	my $result = $self->{package_name};
	if (defined($self->{relation})) {
		# there is versioned info
		$result .= join('', " (", $self->{relation}, ' ', $self->{version}, ')');
	}
	return $result;
}

sub stringify_relations {
	my @relation_strings;
	foreach my $object (@{$_[0]}) {
		if (UNIVERSAL::isa($object, 'Cupt::Cache::Relation')) {
			# it's ordinary relation object
			push @relation_strings, $object->stringify();
		} else {
			# it have be an 'OR' group of relations
			push @relation_strings, join(" | ", map { $_->stringify() } @$object);
		}
	}
	return join(", ", @relation_strings);
}

sub __parse_relation_line {
	# my $relation_line = $_[0] 
	# or myinternaldie("relation line is not defined");

	my @result;
	while ($_[0] =~ m/(.+?)(?:,\s*|$)/g) {
		# looking for OR groups
		my @relations = split / ?\| ?/, $1;
		if (scalar @relations == 1) {
			# ordinary relation
			push @result, new Cupt::Cache::Relation($relations[0]);
		} else {
			# 'OR' group of relations
			push @result, [ map { new Cupt::Cache::Relation($_) } @relations ];
		}
	}
	return \@result;
}

1;

package Cupt::Cache::SourcePkg::Version;
# TODO: full rework

import Cupt::Core;
import Cupt::Cache::Relation;

sub new {
	my $class = shift;
	my $self = fields::new($class);

	# parsing fields
	my $ref_lines = shift;

	my $field_name = undef;
	eval {
		foreach my $line (@$ref_lines) {
			if ($line =~ m/^ /) {
				# part of long description
				$self->{long_description} .= $line;
			} else {
				(($field_name, my $field_value) = ($line =~ m/^((\w|-)+?): (.*)$/))
					or mydie("cannot parse line '%s'", $line);

				given ($field_name) {
					when ('Priority') { $self->{priority} = $field_value }
					when ('Section') { $self->{section} = $field_value }
					when ('Installed-Size') { $self->{installed_size} = $field_value }
					when ('Maintainer') { $self->{maintainer} = $field_value }
					when ('Source') { $self->{source_name} = $field_value }
					when ('Architecture') { $self->{architecture} = $field_value }
					when ('Version') { $self->{version} = $field_value }
					when ('Depends') { $self->{depends} = __parse_relation_line($line) }
					when ('Recommends') { $self->{recommends} = __parse_relation_line($line) }
					when ('Suggests') { $self->{suggests} = __parse_relation_line($line) }
					when ('Pre-Depends') { $self->{pre_depends} = __parse_relation_line($line) }
					when ('Enhances') { $self->{enhances} = __parse_relation_line($line) }
					when ('Breaks') { $self->{breaks} = __parse_relation_line($line) }
					when ('Provides') { $self->{provides} = __parse_relation_line($line) }
					when ('Conflicts') { $self->{conflicts} = __parse_relation_line($line) }
					when ('Filename') { push @{$self->{uris}}, $field_value }
					when ('Size') { $self->{size} = $field_value }
					when ('MD5sum') { $self->{md5sum} = $field_value }
					when ('SHA1') { $self->{sha1sum} = $field_value }
					when ('SHA256') { $self->{sha256sum} = $field_value }
					when ('Description') { $self->{short_description} = $field_value }
				}
				undef $field_name;
			}
		}
	};
	if (mycatch()) {
		if (defined($field_name)) {
			myerr("error while parsing field '%s'", $field_name);
		}
		myredie();
	}

	return $self;
}

sub is_hashes_equal {
	my $self = shift;
	my $other = shift;
	return ($self->{md5sum} eq $other->{md5sum} &&
			$self->{sha1sum} eq $other->{sha1sum} &&
			$self->{sha256sum} eq $other->{sha256sum});
}

1;

package Cupt::Cache::BinaryPkg::Version;

import Cupt::Core;
import Cupt::Cache::Relation qw(__parse_relation_line);

# parsing options
our $o_no_parse_relations = 0; # don't parse depends, recommends, conflicts etc
our $o_no_parse_info_onlys = 0; # don't parse maintainer, descriptions, tag, homepage

sub new {
	my ($class, $ref_arg) = @_;
	my $self = {
		avail_as => [],
		# should contain array of hashes
		#	release => {
		#		...
		#	},
		#	base_uri
		#	filename

		priority => undef,
		section => undef,
		installed_size => undef,
		maintainer => undef,
		architecture => undef,
		source_name => undef,
		version => undef,
		essential => undef,
		depends => undef,
		recommends => undef,
		suggests => undef,
		conflicts => undef,
		breaks => undef,
		enhances => undef,
		provides => undef,
		replaces => undef,
		pre_depends => undef,
		size => undef,
		md5sum => undef,
		sha1sum => undef,
		sha256sum => undef,
		short_description => undef,
		long_description => undef,
		homepage => undef,
		task => undef,
		tags => undef,
	};
	# parsing fields
	my ($package_name, $fh, $offset, $base_uri, $ref_release_info) = @$ref_arg;

	$self->{avail_as}->[0]->{base_uri} = $base_uri;
	$self->{avail_as}->[0]->{release} = $ref_release_info;
	$self->{source_name} = $package_name; # default, if not specified

	my $field_name = undef;
	eval {
		my $line;
		# go to starting byte of the entry
		seek $fh, $offset, 0;
		# we have already opened file handle and offset for reading the entry
		while (($line = <$fh>) ne "\n") {
			if (($line =~ m/^ / or $line =~ m/^\t/)) {
				# TODO: remove this bogus '\t' after libobject-declare-perl is fixed
				# part of long description
				$self->{long_description} .= $line unless $o_no_parse_info_onlys;
			} else {
				chomp($line);
				(($field_name, my $field_value) = ($line =~ m/^((?:\w|-)+?): (.*)/)) # '$' implied in regexp
					or mydie("cannot parse line '%s'", $line);

				given ($field_name) {
					# mandatory fields
					when ('Priority') { $self->{priority} = $field_value }
					when ('Section') { $self->{section} = $field_value }
					when ('Installed-Size') { $self->{installed_size} = $field_value }
					when ('Maintainer') { $self->{maintainer} = $field_value unless $o_no_parse_info_onlys }
					when ('Architecture') { $self->{architecture} = $field_value }
					when ('Version') { $self->{version} = $field_value }
					when ('Filename') { $self->{avail_as}->[0]->{filename} = $field_value }
					when ('Size') { $self->{size} = $field_value }
					when ('MD5sum') { $self->{md5sum} = $field_value }
					when ('SHA1') { $self->{sha1sum} = $field_value }
					when ('SHA256') { $self->{sha256sum} = $field_value }
					when ('Description') { $self->{short_description} = $field_value unless $o_no_parse_info_onlys }
					# often fields
					when ('Depends') {
						$self->{depends} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Tag') { $self->{tags} = $field_value unless $o_no_parse_info_onlys }
					when ('Source') { $self->{source_name} = $field_value }
					when ('Homepage') { $self->{homepage} = $field_value unless $o_no_parse_info_onlys }
					when ('Recommends') {
						$self->{recommends} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Suggests') {
						$self->{suggests} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Conflicts') {
						$self->{conflicts} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Replaces') {
						$self->{replaces} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Provides') {
						$self->{provides} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					# rare fields
					when ('Pre-Depends') {
						$self->{pre_depends} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Task') { $self->{homepage} = $field_value }
					when ('Enhances') {
						$self->{enhances} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
					when ('Essential') { $self->{essential} = $field_value }
					when ('Breaks') {
						$self->{breaks} = __parse_relation_line($field_value) unless $o_no_parse_relations;
					}
				}
				undef $field_name;
			}
		}
	};
	if (mycatch()) {
		if (defined($field_name)) {
			myerr("error while parsing field '%s'", $field_name);
		}
		myredie();
	}
	return bless $self => $class;
}

sub is_hashes_equal {
	my $self = shift;
	my $other = shift;
	return ($self->{md5sum} eq $other->{md5sum} &&
			$self->{sha1sum} eq $other->{sha1sum} &&
			$self->{sha256sum} eq $other->{sha256sum});
}

sub uris {
	my $self = shift;
	map { $_->{base_uri} . '/dists/' . $_->{filename} } @{$self->{avail_as}};
}

1;

package Cupt::Cache::Pkg;

import Cupt::Core;

sub new {
	my ($class) = @_;
	my $self = []; # only unparsed versions
	return bless $self => $class;
}

# adds unparsed entry to package
sub add_entry {
	my $self = shift;
	push @$self, \@_;
}

# returns reference to versions array
sub versions {
	my $self = shift;

	my @result;
	# in case parsing of versions of this package was delayed, we parse them now (on-demand)
	eval {
		foreach (@$self) {
			$self->_parse_and_merge_version($_, \@result);
		}
	};
	if (mycatch()) {
		myerr("error while parsing package info");
		myredie();
	};

	return \@result;
}

sub find_version {
	my $self = shift;
	my $lookup_version = shift;

	foreach my $version (@{$self->versions()})
	{
		return $version if ($version->{version} eq $lookup_version);
	}
	return undef;
}

sub _parse_and_merge_version {
	# parsing
	my ($self, $entry, $ref_result) = @_;
	my $parsed_version;
	eval {
		$parsed_version = $self->_construct_version($entry);
	};
	if (mycatch()) {
		myerr("error while parsing new version entry");
		myredie();
	}

	# merging
	eval {
		my $found_version;
		foreach my $version (@$ref_result)
		{
			if ($version->{version} eq $parsed_version->{version}) {
				$found_version = $version;
				last;
			}
		}
		if (!defined($found_version)) {
			# no such version before, just add it
			push @$ref_result, $parsed_version;
		} else {
			# there is such version string

			# checking hash sums
			# TODO: how this is supposed to work now? look deeper
			if (is_hashes_equal($found_version, $parsed_version))
			{
				# ok, this is the same entry; looking maybe it defines new uri for package?
				my $uri_from_parsed_version = $parsed_version->{uris}->[0];
				if (!(grep $_ eq $uri_from_parsed_version, @$found_version->{uris})) {
					# yes, it defines, so adding it
					push @{$found_version->{uris}}, $uri_from_parsed_version;
				}
			} else {
				# err, no, this is different package :(
				# just skip it for now
			}
		}
	};
	if (mycatch()) {
		myerr("error while merging version '%s'", $parsed_version->{version});
		myredie();
	};
}

1;

package Cupt::Cache::SourcePkg;

use base qw(Cupt::Cache::Pkg);

sub _construct_version {
	my $entry = shift;
	return new Cupt::Cache::SourcePkg::Version($entry);
}

1;

package Cupt::Cache::BinaryPkg;

use base qw(Cupt::Cache::Pkg);

sub _construct_version {
	return new Cupt::Cache::BinaryPkg::Version($_[1]);
}

1;

package Cupt::Cache;
# TODO: implement parsing /var/lib/dpkg/status
# TODO: sub pinned_versions { ... }
# TODO: implement checking for signedness
# TODO: implement reading /etc/apt/preferences

import Cupt::Core;

use fields qw(source_packages binary_packages config);

sub new {
	my $class = shift;
	my $self = fields::new($class);
	$self->{config} = shift;
	my $ref_index_entries;
	eval {
		$ref_index_entries = $self->_parse_sources_lists();
	};
	if (mycatch()) {
		myerr("error while parsing sources list");
		myredie();
	}

	# determining which parts of cache we wish to build
	my %build_config = (
		'-source' => 1,
		'-binary' => 1,
		@_ # applying passed parameters
	);

	my @index_files_to_parse = map { $self->_path_of_source_list($_) } @$ref_index_entries;
	foreach my $idx (0 .. $#index_files_to_parse) {
		my $source_type = $ref_index_entries->[$idx]{'type'};
		# don't parse unneeded indexes
		if (($source_type eq 'deb' && $build_config{'-binary'}) ||
			($source_type eq 'deb-src' && $build_config{'-source'}))
		{
			eval {
				my $ref_release_info = __get_release_info($self->_path_of_release_list($ref_index_entries->[$idx]));
				$self->_process_index_file($index_files_to_parse[$idx], $source_type, $ref_release_info);
			};
			if (mycatch()) {
				mywarn("skipped index file '%s'", $index_files_to_parse[$idx]);
			}
		}
	}
	return $self;
}

sub get_pin {
	# TODO: implement pin '100' for installed packages?
	my ($self, $version) = @_;
	my $result;

	my $update_pin = sub ($) {
		if (!defined($result)) {
			$result = $_[0];
		} elsif ($result < $_[0]) {
			$result = $_[0];
		}
	};

	# release-dependent settings
	my $default_release = $self->{config}->var("apt::default-release");
	foreach (@{$version->{avail_as}}) {
		if (defined($default_release)) {
			if ($_->{release}->{archive} eq $default_release ||
				$_->{release}->{codename} eq $default_release)
			{
				$update_pin->(990);
				last; # no sense to search further, this is maximum
			}
		}
		if ($_->{release}->{archive} eq 'experimental') {
			$update_pin->(1);
		} else {
			$update_pin->(500);
		}
	}

	return $result;
}

sub __get_release_info {
	my $file = shift;

	my %release_info = (
		'version' => undef,
		'description' => undef,
		'signed' => 0,
		'vendor' => undef,
		'label' => undef,
		'archive' => undef,
		'codename' => undef,
		'date' => undef,
		'valid-until' => undef,
		'architectures' => undef,
	);

	open(RELEASE, '<', $file) or mydie("unable to open release file '%s'", $file);
	my $field_name = undef;
	eval {
		while (<RELEASE>) {
			(($field_name, my $field_value) = ($_ =~ m/^((?:\w|-)+?): (.*)/)) # '$' implied in regexp
				or last;

			given ($field_name) {
				when ('Origin') { $release_info{vendor} = $field_value }
				when ('Label') { $release_info{label} = $field_value }
				when ('Suite') { $release_info{archive} = $field_value }
				when ('Codename') { $release_info{codename} = $field_value }
				when ('Date') { $release_info{date} = $field_value }
				when ('Valid-Until') { $release_info{valid_until} = $field_value }
				when ('Architectures') { $release_info{architectures} = [ split / /, $field_value ] }
				when ('Description') {
					$release_info{description} = $field_value;
					if ($field_value =~ m/([0-9a-z._-]+)/) {
						$release_info{version} = $1;
					}
				}
			}

			undef $field_name;
		}
	};
	if (mycatch()) {
		myerr("error parsing release file '%s', line '%d'", $file, $.);
		myredie();
	}
	if (!defined($release_info{description})) {
		mydie("no description specified in release file '%s'", $file);
	}
	if (!defined($release_info{vendor})) {
		mydie("no vendor specified in release file '%s'", $file);
	}
	if (!defined($release_info{archive})) {
		mydie("no archive specified in release file '%s'", $file);
	}
	if (!defined($release_info{codename})) {
		mydie("no codename specified in release file '%s'", $file);
	}

	close(RELEASE) or mydie("unable to close index file '%s'", $file);
	return \%release_info;
}

sub _parse_sources_lists {
	my $self = shift;
	my $root_prefix = $self->{config}->var('dir');
	my $etc_dir = $self->{config}->var('dir::etc');

	my $parts_dir = $self->{config}->var('dir::etc::sourceparts');
	my @source_files = glob("$root_prefix$etc_dir/$parts_dir/*");

	my $main_file = $self->{config}->var('dir::etc::sourcelist');
	push @source_files, "$root_prefix$etc_dir/$main_file";

	my @result;
	foreach (@source_files) {
		push @result, __parse_source_list($_);
	}

	return \@result;
}

sub __parse_source_list {
	my $file = shift;
	my @result;
	open(HFILE, '<', "$file") or mydie("unable to open file %s: %s", $file, $!);
	while (<HFILE>) {
		chomp;
		# skip all empty lines and lines with comments
		next if m/^\s*(?:#.*)?$/;

		my %entry;
		($entry{'type'}, $entry{'uri'}, $entry{'distribution'}, my @sections) = split / +/;
		#print %entry;

		mydie("incorrent source line at file %s, line %d", $file, $.) if (!scalar @sections);
		mydie("incorrent source type at file %s, line %d", $file, $.)
			if ($entry{'type'} ne 'deb' && $entry{'type'} ne 'deb-src');

		map { $entry{'section'} = $_; push @result, { %entry }; } @sections;
	}
	close(HFILE) or mydie("unable to close file %s: %s", $file, $!);
	return @result;
}

sub _process_index_file {
	my ($self, $file, $type, $ref_release_info) = @_;

	# TODO: implement proper base uri detection
	my $base_uri = 'fakeuri://fake.org';

	my $package_class;
	my $packages_storage;
	if ($type eq 'deb') {
		$package_class = 'Cupt::Cache::BinaryPkg';
		$packages_storage = \$self->{binary_packages};
	} elsif ($type eq 'deb-src') {
		$package_class = 'Cupt::Cache::SourcePkg';
		$packages_storage = \$self->{source_packages};
		mywarn("not parsing deb-src index '%s' (parsing code is broken now)", $file);
		return;
	}

	my $fh;
	open($fh, '<', $file) or mydie("unable to open index file '%s'", $file);
	open(OFFSETS, "/bin/grep -b '^Package: ' $file |"); 

	eval {
		while (<OFFSETS>) {
			if (m/^(\d+):Package: (.*)/) { # '$' implied in regexp
				my $package_name = $2;

				# offset is returned by grep -b, and we skips 'Package: <...>' line additionally
				my $offset = $1 + length("Package: $package_name\n");

				# check it for correctness
				($package_name =~ m/^$package_name_regex$/)
					or mydie("bad package name '%s'", $package_name);

				# end of entry, so creating new package
				$$packages_storage->{$package_name} //= $package_class->new();
				Cupt::Cache::Pkg::add_entry($$packages_storage->{$package_name},
						$package_name, $fh, $offset, $base_uri, $ref_release_info);
			} else {
				mydie("expected 'Package' line, but haven't got it");
			}
		}
	};
	if (mycatch()) {
		myerr("error parsing index file '%s', line '%d'", $file, $.);
		myredie();
	}

	close(OFFSETS);
}

sub _path_of_base_uri {
	my $self = shift;
	my $entry = shift;

	# "http://ftp.ua.debian.org" -> "ftp.ua.debian.org"
	(my $uri_prefix = $entry->{'uri'}) =~ s[^\w+://][];

	# "ftp.ua.debian.org/debian" -> "ftp.ua.debian.org_debian"
	$uri_prefix =~ tr[/][_];

	my $dirname = join('',
		$self->{config}->var('dir'),
		$self->{config}->var('dir::state'),
		'/',
		$self->{config}->var('dir::state::lists')
	);

	my $base_uri_part = join('_',
		$uri_prefix,
		'dists',
		$entry->{'distribution'}
	);

	return join('', $dirname, '/', $base_uri_part);
}

sub _path_of_source_list {
	my $self = shift;
	my $entry = shift;

	my $arch = $self->{config}->var('apt::architecture');
	my $suffix = ($entry->{'type'} eq 'deb') ? "binary-${arch}_Packages" : 'source_Sources';

	my $filename = join('_', $self->_path_of_base_uri($entry), $entry->{'section'}, $suffix);

	return $filename;
}

sub _path_of_release_list {
	my $self = shift;
	my $entry = shift;

	my $filename = join('_', $self->_path_of_base_uri($entry), 'Release');

	return $filename;
}

package main;

use Getopt::Long;
Getopt::Long::Configure('pass_through', 'no_auto_abbrev');

use Locale::gettext;

import Cupt::Core;
import Cupt::Config;
import Cupt::Cache;
import Cupt::Cache::Relation qw(stringify_relations);

my $config;
my $cache;

# build config at start
eval {
	$config = new Cupt::Config;
};
if (mycatch()) {
	myerr("error while loading config");
	exit 1;
}

process_options();

my $command = shift @ARGV;

myerr("no command specified") and exit 2 if (!defined($command));

my %command_handlers = (
	'config-dump' => \&config_dump,
	'show' => \&show_package_versions,
	'search' => \&search,
	'depends' => \&show_package_relations,
);

if (defined($command_handlers{$command})) {
	eval {
		$command_handlers{$command}->();
	};
	if (mycatch()) {
		myerr("error performing command '%s'", $command);
		exit 3;
	}
} else {
	myerr("unrecognized command") and exit 2;
}

sub build_cache {
	eval {
		# propagate any parameters passed to Cupt::Cache::&new
		$cache = new Cupt::Cache($config, @_);
	};
	if (mycatch()) {
		myerr("error while creating package cache");
		exit 1;
	}
}

sub check_package_name ($) {
	if (! ($_[0] =~ m/$package_name_regex/)) {
		mydie("bad package name '%s'", $_[0]);
	}
}

sub check_version_string ($) {
	if (! ($_[0] =~ m/$version_string_regex/)) {
		mydie("bad version string '%s'", $_[0]);
	}
}

sub select_binary_package_version {
	my ($package_expression) = @_;

	my $get_package_versions = sub {
		my ($package_name) = @_;
		if (exists $cache->{binary_packages}->{$package_name}) {
			return $cache->{binary_packages}->{$package_name}->versions();
		} else {
			mydie("cannot find binary package '%s'", $package_name);
		}
	};

	if ($package_expression =~ m/^(.*?)=(.*)/) {
		# selecting by strict version string
		my $package_name = $1;
		check_package_name($package_name);
		my $version_string = $2;
		check_version_string($version_string);
		# example: "nlkt=0.3.2.1-1"
		foreach my $version (@{$get_package_versions->($package_name)}) {
			if ($version->{version} eq $version_string) {
				# found such a version
				return ($package_name, $version);
			}
		}
		# not found
		mydie("cannot find version '%s' for package '%s'", $version_string, $package_name);
	} elsif ($package_expression =~ m/^(.*?)\/(.*)/) {
		# selecting by release distibution
		my $package_name = $1;
		check_package_name($package_name);
		my $distribution_expression = $2;
		if (! ($distribution_expression =~ m/^[a-z]+$/)) {
			mydie("bad distribution '%s' requested, use archive or codename", $distribution_expression);
		}
		# example: "nlkt/sid" or "nlkt/unstable"
		foreach my $version (@{$get_package_versions->($package_name)}) {
			foreach (@{$version->{avail_as}}) {
				if (defined($_->{release}) and
					$_->{release}->{archive} eq $distribution_expression ||
					$_->{release}->{codename} eq $distribution_expression)
				{
					# found such a version
					return ($package_name, $version);
				}
			}
		}
		# not found
		mydie("cannot find distribution '%s' for package '%s'", $distribution_expression, $package_name);
	} else {
		# TODO: move this to 'Cupt::Cache'
		# selecting by policy (pins)
		my $result_version;
		my $max_pin;

		foreach my $version (@{$get_package_versions->($package_expression)}) {
			my $new_pin = $cache->get_pin($version);
			if (!defined($max_pin) || $max_pin < $new_pin) {
				$max_pin = $new_pin;
				$result_version = $version;
			}
		}

		# we assume that every existent package have at least one version
		# this is how we add versions in 'Cupt::Cache::&_process_index_file'

		return ($package_expression, $result_version);
	}
}

sub check_for_extra_args {
	if (scalar @ARGV > 0) {
		mywarn("extra arguments '%s' are not processed", "@ARGV");
	}
}

sub config_dump {
	my $print_key_value = sub {
		my $key = shift;
		my $value = shift;
		print $key, ' ', "\"", $value, "\"\n";
	};

	my @regular_keys = sort keys %{$config->{regular_vars}};
	foreach my $key (@regular_keys) {
		$print_key_value->($key, $config->{regular_vars}->{$key});
	}

	my @list_keys = sort keys %{$config->{list_vars}};
	foreach my $key (@list_keys) {
		my @values = @{$config->{list_vars}->{$key}};
		foreach (@values) {
			$print_key_value->("${key}::", $_);
		}
	}
}

sub show_package_versions {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1);

	my $o_with_release_info = 0;
	GetOptions(
		'--with-release-info' => \$o_with_release_info
	);	
	# TODO: implement '--[no-]all-versions'

	my @package_names = @ARGV;
	foreach my $package_name (@package_names) {
		my $ref_package = exists $cache->{binary_packages}->{$package_name} ?
			$cache->{binary_packages}->{$package_name} : undef;

		if (!defined($ref_package)) {
			mywarn("know nothing about package '%s', skipped", $package_name);
			next;
		}

		my $ref_versions = $ref_package->versions();

		my $p = sub { print gettext(shift), ': ', shift, "\n" };
		foreach my $version (@$ref_versions) {
			$p->('Package', $package_name);
			$p->('Source', $version->{source_name});
			$p->('Priority', $version->{priority});
			$p->('Section', $version->{section});
			$p->('Installed-Size', $version->{installed_size});
			$p->('Maintainer', $version->{maintainer});
			$p->('Architecture', $version->{architecture});
			$p->('Version', $version->{version});
			if ($o_with_release_info) {
				foreach (@{$version->{avail_as}}) {
					next if !defined($_); # no release info available
					$p->('Release', $_->{release}->{description});
				}
			}
			$p->('Essential', $version->{essential}) if defined($version->{essential});
			$p->('Depends', stringify_relations($version->{depends})) if defined($version->{depends});
			$p->('Recommends', stringify_relations($version->{recommends})) if defined($version->{recommends});
			$p->('Suggests', stringify_relations($version->{suggests})) if defined($version->{suggests});
			$p->('Conflicts', stringify_relations($version->{conflicts})) if defined($version->{conflicts});
			$p->('Replaces', stringify_relations($version->{replaces})) if defined($version->{replaces});
			$p->('Provides', stringify_relations($version->{provides})) if defined($version->{provides});
			$p->('Enhances', stringify_relations($version->{enhances})) if defined($version->{enhances});
			foreach ($version->uris()) {
				$p->('URI', $_);
			}
			$p->('Size', $version->{size});
			$p->('MD5', $version->{md5sum});
			$p->('SHA1', $version->{sha1sum});
			$p->('SHA256', $version->{sha256sum});
			$p->('Description', $version->{short_description});
			# TODO: translated descriptions...
			print $version->{long_description} if defined ($version->{long_description});
			$p->('Homepage', $version->{homepage}) if defined($version->{homepage});
			$p->('Task', $version->{task}) if defined($version->{task});
			$p->('Tag', $version->{tags}) if defined($version->{tags});
			print "\n";
		}
	}
}

sub search {
	# we need to build binary-only cache for this operation
	build_cache('-source' => 0, '-binary' => 1);

	# turn off relations parsing, we don't need them
	$Cupt::Cache::BinaryPkg::Version::o_no_parse_relations = 1;

	my $o_names_only = 0;
	my $o_case_sensitive = 0;
	GetOptions(
		'--names-only' => \$o_names_only,
		'--case-sensitive' => \$o_case_sensitive,
	);

	my $pattern = shift @ARGV;
	check_for_extra_args();

	my $regex = $o_case_sensitive ? qr/$pattern/ : qr/$pattern/i;

	if ($o_names_only) {
		# search only in package names
		foreach (keys %{$cache->{binary_packages}}) {
			if (m/$regex/) {
				say;
			}
		}
	} else {
		PACKAGE:
		while (my ($package_name, $package) = each %{$cache->{binary_packages}}) {
			if ($package_name =~ m/$regex/) {
				say $package_name;
				next;
			}
			foreach (@{$package->versions()}) {
				if ($_->{short_description} =~ m/$regex/ or
					defined($_->{long_description}) && $_->{long_description} =~ m/$regex/)
				{
					say $package_name . " - " . $_->{short_description};
					next PACKAGE;
				}
			}
		}
	}
}

sub show_package_relations {
	# we need to build binary-only cache for this operation
	build_cache('-source' => 0, '-binary' => 1);

	# turn off info parsing, we don't need it, only relations :)
	$Cupt::Cache::BinaryPkg::Version::o_no_parse_info_onlys = 1;

	my @package_expressions = @ARGV;

	foreach (@package_expressions) {
		my ($package_name, $version) = select_binary_package_version($_);
		say $package_name . " - " . $version->{version};
	}

	# TODO: implement it!
}

sub process_options {
	# strip options out (for now)
	my @direct_options;
	eval {
		GetOptions(
			'o=s@' => \@direct_options
		);
		foreach (@direct_options) {
			if (m/(.*?)=(.*)/) {
				my ($key, $value) = ($1, $2);
				if ($key =~ m/^(.*?)::$/) {
					# this is list option
					$config->set_list_var($1, $value);
				} else {
					# regular option
					$config->set_regular_var($key, $value);
				}
			}
		}
	};
	if (mycatch()) {
		myerr("error while processing command-line options");
		exit 2;
	}
}

__END__

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2008 Eugene V. Lyubimkin

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

