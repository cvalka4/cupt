#!/usr/bin/perl
#BEGIN { $SIG{__DIE__} = sub { require Carp; Carp::confess(@_) } }

package main;

use 5.10.0;
use warnings;
use strict;

use Getopt::Long;
Getopt::Long::Configure('pass_through', 'no_auto_abbrev');

use Locale::gettext;

use Cupt::Core;
use Cupt::Config;
use Cupt::Cache;
use Cupt::Cache::Relation qw(stringify_relations);

my $config;
my $cache;

# build config at start
eval {
	$config = new Cupt::Config;
};
if (mycatch()) {
	myerr("error while loading config");
	exit 1;
}

process_options();

my $command = shift @ARGV;
while ($command =~ m/^-/) { # this is some option which may be processed later
	my $new_command = shift @ARGV;
	unshift @ARGV, $command;
	$command = $new_command;
}

myerr("no command specified") and exit 2 if (!defined($command));

my %command_handlers = (
	'config-dump' => \&config_dump,
	'show' => \&show_package_versions,
	'search' => \&search,
	'depends' => \&show_package_relations,
);

if (defined($command_handlers{$command})) {
	eval {
		$command_handlers{$command}->();
	};
	if (mycatch()) {
		myerr("error performing command '%s'", $command);
		exit 3;
	}
} else {
	myerr("unrecognized command '%s'", $command) and exit 2;
}

sub build_cache {
	eval {
		# propagate any parameters passed to Cupt::Cache::&new
		$cache = new Cupt::Cache($config, @_);
	};
	if (mycatch()) {
		myerr("error while creating package cache");
		exit 1;
	}
}

sub check_package_name ($) {
	if (! ($_[0] =~ m/^$package_name_regex$/)) {
		mydie("bad package name '%s'", $_[0]);
	}
}

sub check_version_string ($) {
	if (! ($_[0] =~ m/^$version_string_regex$/)) {
		mydie("bad version string '%s'", $_[0]);
	}
}

sub check_no_extra_args {
	if (scalar @ARGV > 0) {
		mywarn("extra arguments '%s' are not processed", "@ARGV");
	}
}

sub check_no_more_options {
	foreach (@ARGV) {
		m/^-/ and mydie("unknown option '%s'", $_);
	}
}

sub select_binary_package_version {
	my ($package_expression) = @_;

	my $get_package = sub {
		my ($package_name) = @_;
		if (exists $cache->{binary_packages}->{$package_name}) {
			return $cache->{binary_packages}->{$package_name};
		} else {
			mydie("cannot find binary package '%s'", $package_name);
		}
	};

	if ($package_expression =~ m/^(.*?)=(.*)/) {
		# selecting by strict version string
		my $package_name = $1;
		check_package_name($package_name);
		my $version_string = $2;
		check_version_string($version_string);
		# example: "nlkt=0.3.2.1-1"
		foreach my $version (@{$get_package->($package_name)->versions()}) {
			if ($version->{version} eq $version_string) {
				# found such a version
				return $version;
			}
		}
		# not found
		mydie("cannot find version '%s' for package '%s'", $version_string, $package_name);
	} elsif ($package_expression =~ m/^(.*?)\/(.*)/) {
		# selecting by release distibution
		my $package_name = $1;
		check_package_name($package_name);
		my $distribution_expression = $2;
		if (! ($distribution_expression =~ m/^[a-z]+$/)) {
			mydie("bad distribution '%s' requested, use archive or codename", $distribution_expression);
		}
		# example: "nlkt/sid" or "nlkt/unstable"
		foreach my $version (@{$get_package->($package_name)->versions()}) {
			# 'avail as' for non-local versions
			my @avail_as = @{$version->{avail_as}};
			# first avail entry is for local version
			shift @avail_as if $version->is_local();

			foreach (@avail_as) {
				if (defined($_->{release}) and
					$_->{release}->{archive} eq $distribution_expression ||
					$_->{release}->{codename} eq $distribution_expression)
				{
					# found such a version
					return $version;
				}
			}
		}
		# not found
		mydie("cannot find distribution '%s' for package '%s'", $distribution_expression, $package_name);
	} else {
		my $result_version = $cache->get_policy_version($get_package->($package_expression));
		return $result_version;
	}
}

sub config_dump {
	check_no_more_options();
	check_no_extra_args();

	my $print_key_value = sub {
		my $key = shift;
		my $value = shift;
		print $key, ' ', "\"", $value, "\"\n";
	};

	my @regular_keys = sort keys %{$config->{regular_vars}};
	foreach my $key (@regular_keys) {
		$print_key_value->($key, $config->{regular_vars}->{$key});
	}

	my @list_keys = sort keys %{$config->{list_vars}};
	foreach my $key (@list_keys) {
		my @values = @{$config->{list_vars}->{$key}};
		foreach (@values) {
			$print_key_value->("${key}::", $_);
		}
	}
}

sub show_package_versions {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	my $o_with_release_info = 0;
	GetOptions(
		'--with-release-info' => \$o_with_release_info
	);

	check_no_more_options();

	my @package_expressions = @ARGV;
	foreach my $package_expression (@package_expressions) {
		my $package_name;
		my $ref_versions;
		if ($config->var('apt::cache::allversions')) {
			$package_name = $package_expression;
			my $ref_package = exists $cache->{binary_packages}->{$package_name} ?
				$cache->{binary_packages}->{$package_name} : undef;

			if (!defined($ref_package)) {
				mywarn("know nothing about package '%s', skipped", $package_name);
				next;
			}
			$ref_versions = $ref_package->versions();
		} else {
			my $version = select_binary_package_version($package_expression);
			$package_name = $version->{package_name};
			$ref_versions = [ $version ];
		}

		my $p = sub { print gettext(shift), ': ', shift, "\n" };
		foreach my $version (@$ref_versions) {
			$p->('Package', $package_name);
			my $installed_status = $cache->{system_state}->get_status_line($version);
			$p->('Status', $installed_status) if defined($installed_status);
			$p->('Source', $version->{source_name});
			$p->('Priority', $version->{priority});
			$p->('Section', $version->{section});
			$p->('Installed-Size', $version->{installed_size});
			$p->('Maintainer', $version->{maintainer});
			$p->('Architecture', $version->{architecture});
			$p->('Version', $version->{version});
			if ($o_with_release_info) {
				foreach (@{$version->{avail_as}}) {
					next if !defined($_); # no release info available
					$p->('Release', $_->{release}->{description});
				}
			}
			$p->('Essential', $version->{essential}) if defined($version->{essential});
			$p->('Depends', stringify_relations($version->{depends})) if defined($version->{depends});
			$p->('Recommends', stringify_relations($version->{recommends})) if defined($version->{recommends});
			$p->('Suggests', stringify_relations($version->{suggests})) if defined($version->{suggests});
			$p->('Conflicts', stringify_relations($version->{conflicts})) if defined($version->{conflicts});
			$p->('Replaces', stringify_relations($version->{replaces})) if defined($version->{replaces});
			$p->('Provides', stringify_relations($version->{provides})) if defined($version->{provides});
			$p->('Enhances', stringify_relations($version->{enhances})) if defined($version->{enhances});
			foreach ($version->uris()) {
				$p->('URI', ($_ eq "" ? gettext("<locally installed>") : $_));
			}
			$p->('Size', $version->{size}) if defined($version->{size});
			$p->('MD5', $version->{md5sum}) if defined($version->{md5sum});
			$p->('SHA1', $version->{sha1sum}) if defined($version->{sha1sum});
			$p->('SHA256', $version->{sha256sum}) if defined($version->{sha1sum});
			$p->('Description', $version->{short_description});
			# TODO: translated descriptions...
			print $version->{long_description} if defined($version->{long_description});
			$p->('Homepage', $version->{homepage}) if defined($version->{homepage});
			$p->('Task', $version->{task}) if defined($version->{task});
			$p->('Tag', $version->{tags}) if defined($version->{tags});
			print "\n";
		}
	}
}

sub search {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 0);

	# turn off relations parsing, we don't need them
	$Cupt::Cache::BinaryVersion::o_no_parse_relations = 1;

	my $o_names_only = 0;
	my $o_case_sensitive = 0;
	GetOptions(
		'names-only|n' => sub { $config->set_regular_var('apt::cache::namesonly', 1) },
		'case-sensitive' => \$o_case_sensitive,
	);

	my $pattern = shift @ARGV;
	check_no_more_options();
	check_for_extra_args();

	my $regex = $o_case_sensitive ? qr/$pattern/ : qr/$pattern/i;

	if ($config->var('apt::cache::namesonly')) {
		# search only in package names
		foreach (keys %{$cache->{binary_packages}}) {
			if (m/$regex/) {
				say;
			}
		}
	} else {
		PACKAGE:
		while (my ($package_name, $package) = each %{$cache->{binary_packages}}) {
			if ($package_name =~ m/$regex/) {
				say $package_name;
				next;
			}
			foreach (@{$package->versions()}) {
				if ($_->{short_description} =~ m/$regex/ or
					defined($_->{long_description}) && $_->{long_description} =~ m/$regex/)
				{
					say $package_name . " - " . $_->{short_description};
					next PACKAGE;
				}
			}
		}
	}
}

sub show_package_relations {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	# turn off info parsing, we don't need it, only relations :)
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;

	check_no_more_options();

	my @package_expressions = @ARGV;

	foreach (@package_expressions) {
		my $version = select_binary_package_version($_);
		my $package_name = $version->{package_name};
		my $version_string = $version->{version};

		say "$package_name $version_string:";
		my @relation_groups = (
			[ $version->{pre_depends}, 'Pre-Depends' ],
			[ $version->{depends}, 'Depends' ],
			[ $version->{conflicts}, 'Conflicts' ],
		);
		if (!$config->var('apt::cache::important')) {
			push @relation_groups, 
					[ $version->{recommends}, 'Recommends' ],
					[ $version->{suggests}, 'Suggests' ],
					[ $version->{replaces}, 'Replaces' ]
			;
		}

		foreach my $item (@relation_groups) {
			next unless defined($item);

			my $relations = $item->[0];
			my $caption = $item->[1];
			my @split = split /, /,  stringify_relations($relations);
			my $starter = "  " . gettext($caption) . ": ";
			map { say $starter, $_; } @split;
		}
	}
}

sub process_options {
	# strip options out (for now)
	my @direct_options;
	eval {
		GetOptions(
			'o=s@' => \@direct_options,
			'important|i' => sub { $config->set_regular_var('apt::cache::important', 1) },
			'all-versions|a' => sub { $config->set_regular_var('apt::cache::allversions', 1) },
			'no-all-versions' => sub { $config->set_regular_var('apt::cache::allversions', 0) },
			'target-release|default-release|t=s' => sub { $config->set_regular_var('apt::default-release', $_[1]) },
		);
		foreach (@direct_options) {
			if (m/(.*?)=(.*)/) {
				my ($key, $value) = ($1, $2);
				if ($key =~ m/^(.*?)::$/) {
					# this is list option
					$config->set_list_var($1, $value);
				} else {
					# regular option
					$config->set_regular_var($key, $value);
				}
			}
		}
	};
	if (mycatch()) {
		myerr("error while processing command-line options");
		exit 2;
	}
}

__END__

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2008 Eugene V. Lyubimkin

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

