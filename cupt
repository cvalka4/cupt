#!/usr/bin/perl

package main;

use 5.10.0;
use warnings;
use strict;

use Getopt::Long;
Getopt::Long::Configure('pass_through', 'no_auto_abbrev');

use Locale::gettext;

use Cupt::Core;
use Cupt::Config;
use Cupt::Cache;
use Cupt::Cache::Relation qw(stringify_relation_expressions stringify_relation_expression
		parse_relation_expression);

my $config;
my $cache;

# build config at start
eval {
	$config = new Cupt::Config;
};
if (mycatch()) {
	myerr("error while loading config");
	exit 1;
}

process_options();

my $command = shift @ARGV;
while ($command =~ m/^-/) { # this is some option which may be processed later
	my $new_command = shift @ARGV;
	unshift @ARGV, $command;
	$command = $new_command;
}

myerr("no command specified") and exit 2 if (!defined($command));

my %command_handlers = (
	'config-dump' => \&config_dump,
	'show' => \&show_package_versions,
	'search' => \&search,
	'depends' => sub { show_package_relations('normal') },
	'rdepends' => sub { show_package_relations('reverse') },
	'policy' => \&policy,
	'pkgnames' => \&pkgnames,
	'install' => sub { manage_packages('install') },
	'remove' => sub { manage_packages('remove') },
	'purge' => sub { manage_packages('purge') },
	'satisfy' => sub { manage_packages('satisfy') },
	'safe-upgrade' => sub { manage_packages('safe-upgrade') },
	'full-upgrade' => sub { manage_packages('full-upgrade') },
	'markauto' => sub { mark_autoinstalled('markauto') },
	'unmarkauto' => sub { mark_autoinstalled('unmarkauto') },
);

if (defined($command_handlers{$command})) {
	eval {
		$command_handlers{$command}->();
	};
	if (mycatch()) {
		myerr("error performing command '%s'", $command);
		exit 3;
	}
} else {
	myerr("unrecognized command '%s'", $command) and exit 2;
}

sub build_cache {
	eval {
		# propagate any parameters passed to Cupt::Cache::&new
		$cache = new Cupt::Cache($config, @_);
	};
	if (mycatch()) {
		myerr("error while creating package cache");
		exit 1;
	}
}

sub check_package_name ($) {
	if (! ($_[0] =~ m/^$package_name_regex$/)) {
		mydie("bad package name '%s'", $_[0]);
	}
}

sub check_version_string ($) {
	if (! ($_[0] =~ m/^$version_string_regex$/)) {
		mydie("bad version string '%s'", $_[0]);
	}
}

sub check_no_extra_args () {
	if (scalar @ARGV > 0) {
		mywarn("extra arguments '%s' are not processed", "@ARGV");
	}
}

sub check_no_more_options () {
	foreach (@ARGV) {
		m/^-/ and mydie("unknown option '%s'", $_);
	}
}
sub get_binary_package ($) {
	my ($package_name) = @_;
	my $package = $cache->get_binary_package($package_name);
	if (defined $package) {
		return $package;
	} else {
		mydie("cannot find binary package '%s'", $package_name);
	}
}

sub select_binary_package_version ($) {
	my ($package_expression) = @_;

	if ($package_expression =~ m/^(.*?)=(.*)/) {
		# selecting by strict version string
		# example: "nlkt=0.3.2.1-1"
		my $package_name = $1;
		check_package_name($package_name);
		my $version_string = $2;
		check_version_string($version_string);
		my $package = get_binary_package($package_name);
		my $version = $package->get_specific_version($version_string);
		# not found
		if (defined $version) {
			return $version;
		} else {
			mydie("cannot find version '%s' for package '%s'", $version_string, $package_name);
		}
	} elsif ($package_expression =~ m/^(.*?)\/(.*)/) {
		# selecting by release distibution
		my $package_name = $1;
		check_package_name($package_name);
		my $distribution_expression = $2;
		if (! ($distribution_expression =~ m/^[a-z]+$/)) {
			mydie("bad distribution '%s' requested, use archive or codename", $distribution_expression);
		}
		my $package = get_binary_package($package_name);

		# check for "virtual" distributions
		if ($distribution_expression eq 'installed') {
			my $version = $package->get_installed_version();
			defined $version or
					mydie("there is no installed version for package '%s'", $package_name);
			return $version;
		}

		# example: "nlkt/sid" or "nlkt/unstable"
		foreach my $version (@{$package->versions()}) {
			# 'avail as' for non-local versions
			my @avail_as = @{$version->{avail_as}};
			# first avail entry is for local version
			shift @avail_as if $version->is_installed();

			foreach (@avail_as) {
				if (defined($_->{release}) and
					$_->{release}->{archive} eq $distribution_expression ||
					$_->{release}->{codename} eq $distribution_expression)
				{
					# found such a version
					return $version;
				}
			}
		}
		# not found
		mydie("cannot find distribution '%s' for package '%s'", $distribution_expression, $package_name);
	} else {
		my $result_version = $cache->get_policy_version(get_binary_package($package_expression));
		return $result_version;
	}
}

sub config_dump () {
	check_no_more_options();
	check_no_extra_args();

	my $print_key_value = sub {
		my $key = shift;
		my $value = shift;
		defined $value or return;
		print $key, ' ', "\"", $value, "\"\n";
	};

	my @regular_keys = sort keys %{$config->{regular_vars}};
	foreach my $key (@regular_keys) {
		$print_key_value->($key, $config->{regular_vars}->{$key});
	}

	my @list_keys = sort keys %{$config->{list_vars}};
	foreach my $key (@list_keys) {
		my @values = @{$config->{list_vars}->{$key}};
		foreach (@values) {
			$print_key_value->("${key}::", $_);
		}
	}
}

sub show_package_versions () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	my $o_with_release_info = 0;
	GetOptions(
		'--with-release-info' => \$o_with_release_info,
	);

	check_no_more_options();

	my $sub_get_reverse_provides = sub {
		my ($package_name) = @_;

		my $virtual_relation = new Cupt::Cache::Relation("$package_name");
		my $ref_satisfying_versions = $cache->get_satisfying_versions($virtual_relation);
		my @relations;
		foreach (@$ref_satisfying_versions) {
			# we don't need versions of the same package
			my $new_package_name = $_->{package_name};
			$new_package_name ne $package_name or next;

			my $new_relation_version_string = $_->{version_string};
			my $new_relation = new Cupt::Cache::Relation("$new_package_name (= $new_relation_version_string)");
			push @relations, $new_relation;
		}
		return \@relations;
	};

	my @package_expressions = @ARGV;
	foreach my $package_expression (@package_expressions) {
		my $package_name;
		my $ref_versions;
		my $p = sub { print shift, ': ', shift, "\n" };

		if ($config->var('apt::cache::allversions')) {
			$package_name = $package_expression;
			$ref_versions = get_binary_package($package_name)->versions();
		} else {
			if (!defined $cache->get_binary_package($package_expression)
				&& $package_expression =~ /^$package_name_regex$/) {
				# there is no such binary binary, maybe it's virtual?
				my $ref_reverse_provides = $sub_get_reverse_provides->($package_expression);
				if (scalar @$ref_reverse_provides) {
					$p->(__('Virtual package, provided by'), stringify_relation_expressions($ref_reverse_provides));
					$ref_versions = [];
				}
			}
			if (!defined $ref_versions) {
				my $version = select_binary_package_version($package_expression);
				$package_name = $version->{package_name};
				$ref_versions = [ $version ];
			}
		}

		foreach my $version (@$ref_versions) {
			$p->(__('Package'), $package_name);
			$p->(__('Version'), $version->{version_string});
			my $installed_status = $cache->get_system_state()->get_status_for_version($version);
			$p->(__('Status'), defined($installed_status) ? $installed_status->{'status'} : "not installed");
			if ($version->is_installed()) {
				my $is_auto_installed = $cache->is_automatically_installed($package_name);
				$p->(__('Automatically installed'), $is_auto_installed ? __('yes') : __('no'));
			}
			$p->(__('Source'), $version->{source_name});
			$p->(__('Essential'), $version->{essential}) if defined($version->{essential});
			$p->(__('Priority'), $version->{priority});
			$p->(__('Section'), $version->{section});
			$p->(__('Size'), human_readable_size_string($version->{size})) if defined($version->{size});
			$p->(__('Uncompressed size'), human_readable_size_string($version->{installed_size}*1024));
			$p->(__('Maintainer'), $version->{maintainer});
			$p->(__('Architecture'), $version->{architecture});
			if ($o_with_release_info) {
				foreach (@{$version->{avail_as}}) {
					next if !defined($_->{release}->{description}); # no release description available
					$p->(__('Release'), $_->{release}->{description});
				}
			}
			$p->(__('PreDepends'), stringify_relation_expressions($version->{pre_depends})) if @{$version->{pre_depends}};
			$p->(__('Depends'), stringify_relation_expressions($version->{depends})) if @{$version->{depends}};
			$p->(__('Recommends'), stringify_relation_expressions($version->{recommends})) if @{$version->{recommends}};
			$p->(__('Suggests'), stringify_relation_expressions($version->{suggests})) if @{$version->{suggests}};
			$p->(__('Conflicts'), stringify_relation_expressions($version->{conflicts})) if @{$version->{conflicts}};
			$p->(__('Breaks'), stringify_relation_expressions($version->{breaks})) if @{$version->{breaks}};
			$p->(__('Replaces'), stringify_relation_expressions($version->{replaces})) if @{$version->{replaces}};
			$p->(__('Provides'), join(", ", @{$version->{provides}})) if @{$version->{provides}};
			$p->(__('Enhances'), stringify_relation_expressions($version->{enhances})) if @{$version->{enhances}};
			my $ref_reverse_provides = $sub_get_reverse_provides->($package_name);
			if (scalar @$ref_reverse_provides) {
				$p->(__('Provided by'), stringify_relation_expressions($ref_reverse_provides));
			}
			foreach ($version->uris()) {
				$p->(__('URI'), ($_ eq "" ? gettext("<installed>") : $_));
			}
			$p->(__('MD5'), $version->{md5sum}) if defined($version->{md5sum});
			$p->(__('SHA1'), $version->{sha1sum}) if defined($version->{sha1sum});
			$p->(__('SHA256'), $version->{sha256sum}) if defined($version->{sha1sum});
			$p->(__('Description'), $version->{short_description});
			print $version->{long_description} if defined($version->{long_description});
			$p->(__('Homepage'), $version->{homepage}) if defined($version->{homepage});
			$p->(__('Task'), $version->{task}) if defined($version->{task});
			$p->(__('Tags'), $version->{tags}) if defined($version->{tags});
			print "\n";
		}
	}
}

sub search () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 0);

	# turn off relations parsing, we don't need them
	$Cupt::Cache::BinaryVersion::o_no_parse_relations = 1;

	my $o_names_only = 0;
	my $o_case_sensitive = 0;
	GetOptions(
		'names-only|n' => sub { $config->set_regular_var('apt::cache::namesonly', 1) },
		'case-sensitive' => \$o_case_sensitive,
	);

	my $pattern = shift @ARGV;
	check_no_more_options();
	check_no_extra_args();

	my $regex = $o_case_sensitive ? qr/$pattern/ : qr/$pattern/i;

	if ($config->var('apt::cache::namesonly')) {
		# search only in package names
		foreach (keys %{$cache->{binary_packages}}) {
			if (m/$regex/) {
				say;
			}
		}
	} else {
		PACKAGE:
		while (my ($package_name, $package) = each %{$cache->{binary_packages}}) {
			if ($package_name =~ m/$regex/) {
				say $package_name;
				next;
			}
			foreach (@{$package->versions()}) {
				if ($_->{short_description} =~ m/$regex/ or
					defined($_->{long_description}) && $_->{long_description} =~ m/$regex/)
				{
					say $package_name . " - " . $_->{short_description};
					next PACKAGE;
				}
			}
		}
	}
}

sub show_package_relations ($) {
	my ($mode) = @_;

	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	# turn off info parsing, we don't need it, only relations :)
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;

	my $o_with_suggests = 0;
	GetOptions(
		'with-suggests' => \$o_with_suggests,
	);

	check_no_more_options();

	my @versions = map { select_binary_package_version($_) } @ARGV;

	my @relation_groups = (
		[ 'pre_depends', __('Pre-Depends') ],
		[ 'depends', __('Depends') ],
	);
	if (!$config->var('apt::cache::important')) {
		push @relation_groups, 
				[ 'recommends', __('Recommends') ];

		if ($o_with_suggests) {
			push @relation_groups,
					[ 'suggests', __('Suggests') ];
		}
	}

	# don't output the same version more than one time
	my %processed_entries;

	while (scalar @versions) {
		my $version = shift @versions;

		my $package_name = $version->{package_name};
		my $version_string = $version->{version_string};

		next if exists $processed_entries{$package_name,$version_string};
		$processed_entries{$package_name,$version_string} = 1;

		say "$package_name $version_string:";
		foreach my $item (@relation_groups) {
			my $relation_group_name = $item->[0];
			my $caption = $item->[1];

			# [ relation_expression, package_name ]
			my @relation_expressions_and_packages;
			# fill relations with actual relations
			if ($mode eq 'normal') {
				# just add normal dependencies
				@relation_expressions_and_packages = map { [ $_, "" ] } @{$version->{$relation_group_name}};
			} else {
				# we have to check all reverse dependencies for this version
				foreach (values %{$cache->{binary_packages}}) {
					my $reverse_version_candidate = $cache->get_policy_version($_);
					my $needed = 0;
					foreach (@{$reverse_version_candidate->{$relation_group_name}}) {
						# check each relation
						if (ref $_ ne 'ARRAY' && $_->{package_name} eq $package_name) {
							# don't worry about any virtual packages, just check the relation
							if (!defined $_->{relation_string}) {
								# there is no versioned info in relation, all's ok
								$needed = 1;
							} elsif ($_->satisfied_by($version_string)) {
								# versioned info is good
								$needed = 1;
							} else {
								# bad, this is inappropriate relation, stop at this
								last;
							}
						} else {
							# ok, check as common
							my $ref_relation_versions = $cache->get_satisfying_versions($_);
							foreach (@$ref_relation_versions) {
								if ($_->{package_name} eq $package_name && $_->{version_string} eq $version_string) {
									# ok, good
									$needed = 1;
									last;
								}
							}
						}
						if ($needed == 1) {
							# positive result
							push @relation_expressions_and_packages, [ $_, $reverse_version_candidate->{package_name} ];
							last;
						}
					}
				}
			}

			my $starter = "  " . ($mode eq 'reverse' ? __('Reverse-') : '') . $caption . ": ";
			foreach (@relation_expressions_and_packages) {
				say $starter, ($_->[1] ? $_->[1] . ": " : ""), stringify_relation_expression($_->[0]);
			}

			if ($config->var('apt::cache::recursedepends')) {
				# insert recursive depends into queue
				foreach (@relation_expressions_and_packages) {
					if ($mode eq 'normal') {
						# normal depends

						my $ref_satisfying_versions = $cache->get_satisfying_versions($_->[0]);
						# if some versions exist
						if (scalar @$ref_satisfying_versions) {
							# choose only one version
							push @versions, $ref_satisfying_versions->[0];
						}
					} else {
						# reverse depends
						push @versions, $cache->get_policy_version($cache->get_binary_package($_->[1]));
					}
				}
			}
		}
	}
}

sub policy () {
	# we need to build binary-only cache for this operation
	build_cache(-source => 0, -binary => 1, -installed => 1);

	# turn off info and relations parsing, we don't need it
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;
	$Cupt::Cache::BinaryVersion::o_no_parse_relations = 1;

	check_no_more_options();

	my @packages = @ARGV;
	for my $package_name (@packages) {
		my $package = get_binary_package($package_name);
		my $policy_version = $cache->get_policy_version($package);

		my $installed_version_string = $cache->get_system_state()->get_installed_version_string($package_name);
		say "$package_name:";
		say "  " . gettext('Installed') . ": " .
				(defined($installed_version_string) ?
				$installed_version_string : ('(' . gettext('none') . ')'));

		say "  " . gettext('Candidate') . ": " . $policy_version->{version_string};
		say "  " . gettext('Version table') . ":";

		my $ref_versions = $cache->get_sorted_pinned_versions($package);

		foreach my $entry (@$ref_versions) {
			my $version = $entry->{'version'};
			my $pin = $entry->{'pin'};

			if (defined($installed_version_string) && 
				$version->{version_string} eq $installed_version_string)
			{
				print " *** ";
			} else {
				print "     ";
			}

			say $version->{version_string} . ' ' . $pin;
			# throw out local version if present
			my @avail_as = @{$version->{avail_as}};
			shift @avail_as if $version->is_installed();

			foreach (@avail_as) {
				print (' ' x 8);
				print ${$_->{ref_base_uri}} . ' ';
				print $_->{release}->{archive} . '/'. $_->{release}->{component} . ' ';
				say '(' . ($_->{release}->{signed} ? __('signed') : __('unsigned')) . ')';
			}
			if ($version->is_installed()) {
				say ' ' x 8, $config->var('dir::state::status');
			}
		}
	}
}

sub mark_autoinstalled ($) {
	use Cupt::System::Worker;
	my ($mark_action) = @_;
	build_cache(-source => 0, -binary => 0, -installed => 0);

	check_no_more_options();

	my $worker = new Cupt::System::Worker($config, $cache);
	my $markauto = $mark_action eq 'markauto' ? 1 : 0;
	$worker->mark_as_automatically_installed($markauto, @ARGV);
}

sub pkgnames () {
	build_cache(-source => 0, -binary => 1, -installed => 1);

	check_no_more_options();

	my $prefix = "";
	if (scalar @ARGV) {
		$prefix = quotemeta(shift @ARGV);
	}

	check_no_extra_args();

	while ((my $package_name) = each %{$cache->{binary_packages}}) {
		# check package name for pattern and output it
		$package_name =~ m/^$prefix/o and say $package_name;
	}
}

sub generate_management_prompt ($) {
	my ($worker) = @_;

	my $sub_prompt = sub {
		my $ref_desired_packages = $_[0];
		$worker->set_desired_state($ref_desired_packages);

		my $ref_actions_preview = $worker->get_actions_preview();
		# print planned actions
		do {
			my %action_names = (
				'install' => __('INSTALLED'),
				'remove' => __('REMOVED'),
				'upgrade' => __('UPGRADED'),
				'purge' => __('PURGED'),
				'downgrade' => __('DOWNGRADED'),
				'configure' => __('CONFIGURED'),
				'deconfigure' => __('DECONFIGURED'),
			);
			say "";
			foreach my $action (qw(install upgrade remove purge downgrade configure deconfigure)) {
				my $ref_package_entries = $ref_actions_preview->{$action};
				scalar @$ref_package_entries or next; # don't print empty lists
				my $action_name = $action_names{$action};
				say sprintf __("The following packages will be %s:"), $action_name;
				say "";
				my @package_names_list = sort map { $_->{package_name} } @$ref_package_entries;
				say "@package_names_list";
				say "";
			}
		};
		# prepare list of soft dependencies that are not satisfied
		do {
			my @unsatisfied_soft_dependencies;
			my @versions_to_remove;
			foreach my $action (qw(remove purge deconfigure)) {
				my $ref_package_entries = $ref_actions_preview->{$action};
				foreach my $ref_package_entry (@$ref_package_entries) {
					my $package = $cache->get_binary_package($ref_package_entry->{package_name});
					my $version = $package->get_installed_version();
					push @versions_to_remove, $version;
				}
			}
			foreach my $package_name (keys %$ref_desired_packages) {
				my $ref_package_entry = $ref_desired_packages->{$package_name};
				next if !defined $ref_package_entry->{version};

				foreach my $relation_expression (@{$ref_package_entry->{version}->{recommends}}) {
					my $ref_satisfying_versions = $cache->get_satisfying_versions($relation_expression);
					
					my $soft_breakage_possible = 0;
					RELATION_ENTRY:
					foreach my $satisfying_version (@$ref_satisfying_versions) {
						foreach my $version_to_remove (@versions_to_remove) {
							next if $satisfying_version->{package_name} ne $version_to_remove->{package_name};
							next if $satisfying_version->{version_string} ne $version_to_remove->{version_string};
							$soft_breakage_possible = 1;
							last RELATION_ENTRY;
						}
					}

					if ($soft_breakage_possible) {
						my $is_broken = 1;
						foreach my $satisfying_version (@$ref_satisfying_versions) {
							my $satisfying_package_name = $satisfying_version->{package_name};
							next if !defined $ref_desired_packages->{$satisfying_package_name};
							my $desired_version = $ref_desired_packages->{$satisfying_package_name}->{version};
							next if !defined $desired_version;
							next if $desired_version->{version_string} ne $satisfying_version->{version_string};
							$is_broken = 0;
							last;
						}
						if ($is_broken) {
							my $version_string = $ref_package_entry->{version}->{version_string};
							push @unsatisfied_soft_dependencies, 
									sprintf __("%s %s recommends %s"), $package_name, $version_string,
									stringify_relation_expression($relation_expression);
									
						}
					}
				}
			}
			if (scalar @unsatisfied_soft_dependencies) {
				say sprintf __("Leave the following dependencies unresolved:");
				say "";
				say $_ for @unsatisfied_soft_dependencies;
				say "";
			}
		};

		if (!$config->var('apt::get::allowunauthenticated')) {
			my @untrusted_package_names;
			# generate loud warning for unsigned versions
			foreach my $action (qw(install upgrade downgrade)) {
				my $ref_package_entries = $ref_actions_preview->{$action};
				foreach my $version (map { $_->{version} } @$ref_package_entries) {
					push @untrusted_package_names, $version->{package_name} if !$version->is_signed();
				}
			}
			if (scalar @untrusted_package_names) {
				say sprintf __("WARNING! The untrusted versions of the following packages will be installed:");
				say "";
				say $_ for @untrusted_package_names;
				say "";
			}
		}

		# print size estimation
		do {
			my ($total_bytes, $need_bytes) = $worker->get_sizes_preview($ref_actions_preview);
			say sprintf __("Need to get %s/%s of archives."),
					human_readable_size_string($need_bytes),
					human_readable_size_string($total_bytes);
		};

		print __("Do you want to continue? [y/N/q] ");
		my $answer = <STDIN>;
		chomp $answer;
		$answer = lc($answer);
		if ($answer eq 'y') {
			# solution has been accepted
			return 1;
		} elsif ($answer eq 'q') {
			# user is willing to abandon all further tryings
			return undef;
		} else {
			# user haven't chosen this solution, try next one
			print __("Resolving further... ");
			return 0;
		}
	};

	return $sub_prompt;
}

sub manage_packages ($) {
	require Cupt::System::Resolver;
	require Cupt::System::Worker;

	my $o_resolver_type;
	my $o_max_solution_count;
	my $o_simulate;
	GetOptions(
		'resolver=s' => \$o_resolver_type,
		'max-solution-count=s' => \$o_max_solution_count,
	);
	# action can be 'install', 'remove', 'purge', 'safe-upgrade', 'full-upgrade'
	my ($action) = @_;

	local $| = 1;
	print __('Building the package cache... ');
	build_cache(-source => 0, -binary => 1, -installed => 1);
	say __('[done]');

	# turn off info parsing, we don't need it
	$Cupt::Cache::BinaryVersion::o_no_parse_info_onlys = 1;

	check_no_more_options();

	print __('Initializing package resolver and worker... ');
	my $resolver = new Cupt::System::Resolver($config, $cache);
	$resolver->set_params('resolver-type' => $o_resolver_type) if defined $o_resolver_type;
	$resolver->set_params('max-solution-count' => $o_max_solution_count) if defined $o_max_solution_count;
	$resolver->import_installed_versions($cache->get_system_state()->export_installed_versions());
	my $worker = new Cupt::System::Worker($config, $cache);
	say __('[done]');

	print __('Scheduling requested actions... ');
	if ($action eq 'safe-upgrade' || $action eq 'full-upgrade') {
		my $o_no_remove = ($action eq 'safe-upgrade');
		$resolver->set_params('no-remove' => $o_no_remove);
		$resolver->upgrade();

		# despite the main action is {safe,full}-upgrade, allow package
		# modifiers in the command line just as with the install command
		$action = 'install';
	}

	my $o_purge = 0;
	if ($action eq 'purge') {
		$action = 'remove';
		$config->set_regular_var('cupt::worker::purge', 1)
	}

	my @package_expressions = @ARGV;
	foreach my $package_expression (@package_expressions) {
		if ($action eq 'satisfy') {
			my $relation_expression = parse_relation_expression($package_expression);
			$resolver->satisfy_relation_expression($relation_expression);
		} else {
			my $action = $action;
			if (!defined $cache->get_binary_package($package_expression)) {
				# we have a funny situation with package names like 'g++',
				# where one don't know is there simple package name or '+'/'-'
				# modifier at the end of package name, so we enter here only if
				# it seems that there is no such binary package

				# "localizing" action to make it modifiable by package modifiers
				my $last_letter = substr($package_expression, -1, 1);
				if ($last_letter eq '+') {
					$action = 'install';
					$package_expression = substr($package_expression, 0, length($package_expression)-1);
				} elsif ($last_letter eq '-') {
					$action = 'remove';
					$package_expression = substr($package_expression, 0, length($package_expression)-1);
				}
			}

			if ($action eq 'install') {
				my $version = select_binary_package_version($package_expression);
				$resolver->install_version($version);
			} else { # 'remove'
				check_package_name($package_expression);
				defined($cache->get_binary_package($package_expression)) or
						mydie("unable to find binary package '%s'", $package_expression);

				$resolver->remove_package($package_expression);
			}
		}
	}

	say __('[done]');

	print __('Resolving possible unmet dependencies... ');
	my $resolve_result = $resolver->resolve( generate_management_prompt($worker) );

	if (!defined $resolve_result) {
		# tryings were abandoned
	} elsif ($resolve_result) {
		# if some solution was found and user has accepted it
		require Cupt::Download::Progresses::Console;
		my $download_progess = new Cupt::Download::Progresses::Console;
		say __("Performing requested actions:");
		my $overall_result = $worker->do_actions($download_progess);
		mydie("unable to do requested actions") unless $overall_result;
	} else {
		say __("no more solutions.");
	}
}

sub process_options {
	# strip options out (for now)
	my @direct_options;
	eval {
		GetOptions(
			'option|o=s@' => \@direct_options,
			'important|i' => sub { $config->set_regular_var('apt::cache::important', 1) },
			'all-versions|a' => sub { $config->set_regular_var('apt::cache::allversions', 1) },
			'no-all-versions' => sub { $config->set_regular_var('apt::cache::allversions', 0) },
			'target-release|default-release|t=s' => sub { $config->set_regular_var('apt::default-release', $_[1]) },
			'recurse' => sub { $config->set_regular_var('apt::cache::recursedepends', 1) },
			'simulate|s' => sub { $config->set_regular_var('cupt::worker::simulate' => 1) },
			'purge' => sub { $config->set_regular_var('cupt::worker::purge' => 1) },
		);
		foreach (@direct_options) {
			if (m/(.*?)=(.*)/) {
				my ($key, $value) = ($1, $2);
				if ($key =~ m/^(.*?)::$/) {
					# this is list option
					$config->set_list_var($1, $value);
				} else {
					# regular option
					$config->set_regular_var($key, $value);
				}
			} else {
				mydie("incorrect option syntax (right is '<option>=<value>')");
			}
		}
	};
	if (mycatch()) {
		myerr("error while processing command-line options");
		exit 2;
	}
}

__END__

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2008 Eugene V. Lyubimkin

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

